# 변동성 돌파 + 오전오후 전략 구현 가이드

## 핵심 최적화

- **60분봉 사용**: 1분봉 대비 60배 효율 (초기 504개→20일 필터링, 일일 36개→어제 필터링)
- **지표 사전 계산**: 00:00에 한 번만 계산 → 매 1분 체크 시 즉시 사용
- **파일 기반**: JSON으로 간단하게 (DB 불필요)

---

## 동작 흐름

### 00:00 (자정)

#### 1. 데이터 수집

```python
# 초기 실행: 21일치 가져와서 정확히 20일만 사용
# 여유분: 스케줄러 지연, API 응답 시간, 봉 누락 대응
hourly = get_candles(ticker, interval=MINUTE_60, count=504)  # 21일 = 504개

# 타임스탬프 기준 정확히 20일치만 추출
end_time = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
start_time = end_time - timedelta(days=20)
hourly = [c for c in hourly if start_time <= c.timestamp < end_time]
# 봉이 비어있을 수 있으므로 개수가 아닌 일시 기준으로 필터링

# 일일 실행: 36시간치 가져와서 어제 24시간만 추출
# 여유분: 00:00 정확히 실행 안 될 수 있음, 봉 누락 가능
hourly = get_candles(ticker, interval=MINUTE_60, count=36)  # 1.5일

# 어제 00:00 ~ 23:59 데이터만 타임스탬프 기준 필터링
yesterday_start = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0) - timedelta(days=1)
yesterday_end = yesterday_start + timedelta(days=1)
hourly = [c for c in hourly if yesterday_start <= c.timestamp < yesterday_end]
```

#### 2. 오전/오후 집계

```python
morning = HalfDayCandle(
    open=hourly[0].open,
    high=max(c.high for c in hourly[0:12]),
    low=min(c.low for c in hourly[0:12]),
    close=hourly[11].close,
    volume=sum(c.volume for c in hourly[0:12])
)
afternoon = HalfDayCandle(...)  # hourly[12:24]
```

#### 3. 히스토리 저장 (Rolling Window)

```python
# 초기 실행 (파일 없음)
if not file_exists('half_day_candles.json'):
    history = []  # 빈 리스트
    for day in range(20):
        morning, afternoon = collect_day(day)
        history.extend([morning, afternoon])
    save_json('half_day_candles.json', history)  # 40개 저장

# 일일 실행 (파일 있음)
else:
    history = load_json('half_day_candles.json')  # 기존 40개 로드
    morning, afternoon = collect_yesterday()  # 어제치 수집
    history.extend([morning, afternoon])  # 42개가 됨
    save_json('half_day_candles.json', history[-40:])  # 최신 40개만 유지
    # 가장 오래된 2개는 자동으로 버려짐
```

#### 4. 시그널 사전 계산

```python
if len(history) < 40:
    return  # 워밍업 기간

yesterday_morning = history[-2]
yesterday_afternoon = history[-1]
today_open = get_current_price()

# 변동성 돌파
k = calculate_noise_average(history, 20)
threshold = today_open + (yesterday_morning.range * k)
vb_weight = min((target_vol / yesterday_morning.volatility) * ma_score, 1.0)

# 오전오후
afternoon_return = (yesterday_afternoon.close - yesterday_afternoon.open) / yesterday_afternoon.open
volume_ok = yesterday_morning.volume < yesterday_afternoon.volume
ma_weight = min(target_vol / yesterday_morning.volatility, 1.0)

# 저장
signals = {
    'volatility_breakout': {
        'threshold': threshold,
        'buy_weight': vb_weight,
        'already_bought': False
    },
    'morning_afternoon': {
        'condition_met': afternoon_return > 0 and volume_ok,
        'buy_weight': ma_weight,
        'already_bought': False
    }
}
save_json('daily_signals.json', signals)
```

#### 5. 오전오후 전략 실행

```python
if signals['morning_afternoon']['condition_met']:
    buy_amount = get_balance('KRW') * 0.5 * signals['morning_afternoon']['buy_weight']
    if buy_amount >= 5000:
        buy_market_order(ticker, buy_amount)
        signals['morning_afternoon']['already_bought'] = True
```

---

### 00:01 ~ 11:59 (오전) - 매 1분

```python
def check_volatility_breakout():
    signals = load_json('daily_signals.json')

    if signals['volatility_breakout']['already_bought']:
        return

    current_price = get_current_price()

    if current_price > signals['volatility_breakout']['threshold']:
        buy_amount = get_balance('KRW') * 0.5 * signals['volatility_breakout']['buy_weight']
        if buy_amount >= 5000:
            buy_market_order(ticker, buy_amount)
            signals['volatility_breakout']['already_bought'] = True
            save_json('daily_signals.json', signals)
```

---

### 12:00 (정오) - 전량 매도

```python
def sell_all():
    balance = get_balance(ticker.split('-')[1])

    if balance > 0:
        for retry in range(3):
            try:
                sell_market_order(ticker, balance)
                # 시그널 초기화
                signals = load_json('daily_signals.json')
                signals['volatility_breakout']['already_bought'] = False
                signals['morning_afternoon']['already_bought'] = False
                save_json('daily_signals.json', signals)
                return
            except Exception as e:
                if retry < 2:
                    time.sleep(60)
```

---

## 데이터 구조

### half_day_candles.json

```json
[
  {
    "date": "2025-10-13",
    "period": "morning",
    "open": 50000.0,
    "high": 51000.0,
    "low": 49000.0,
    "close": 50500.0,
    "volume": 1234.56
  },
  ...
  (총
  40개
  =
  20일
  *
  2)
]
```

### daily_signals.json

```json
{
  "date": "2025-10-14",
  "volatility_breakout": {
    "threshold": 51234.56,
    "buy_weight": 0.75,
    "already_bought": false
  },
  "morning_afternoon": {
    "condition_met": true,
    "buy_weight": 0.5,
    "already_bought": false
  }
}
```

---

## 파일 구조

```
src/strategy/
├── config.py                # StrategyConfig
├── data/
│   ├── models.py            # HalfDayCandle, DailySignal
│   ├── collector.py         # 60분봉 수집/집계
│   └── storage.py           # JSON 저장/로드
├── indicator/
│   └── calculator.py        # 노이즈, 이평선, 시그널 계산
├── strategies/
│   ├── base.py              # BaseStrategy
│   ├── volatility_breakout.py
│   └── morning_afternoon.py
├── executor.py              # 주문 실행
└── scheduler.py             # 스케줄러

strategy_runner.py           # 메인

data/history/
├── half_day_candles.json
└── daily_signals.json
```

---

## 핵심 컴포넌트

### DataCollector

```python
class DataCollector:
    def collect_initial_data(self, ticker: str, days: int = 20) -> list[HalfDayCandle]:
        """초기: 21일치 가져와서 20일 필터링"""
        hourly = get_candles(ticker, interval=MINUTE_60, count=(days + 1) * 24)
        # 타임스탬프 기준 정확히 days일치만 추출
        end_time = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        start_time = end_time - timedelta(days=days)
        hourly = [c for c in hourly if start_time <= c.timestamp < end_time]
        return self._aggregate_all(hourly, days)

    def collect_daily_data(self, ticker: str) -> tuple[HalfDayCandle, HalfDayCandle]:
        """일일: 36시간치 가져와서 어제만 추출"""
        hourly = get_candles(ticker, interval=MINUTE_60, count=36)
        # 타임스탬프 기준 어제 데이터만 필터링
        yesterday_start = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0) - timedelta(days=1)
        yesterday_end = yesterday_start + timedelta(days=1)
        hourly = [c for c in hourly if yesterday_start <= c.timestamp < yesterday_end]
        return self._aggregate(hourly[0:12]), self._aggregate(hourly[12:24])
```

### SignalCalculator

```python
class SignalCalculator:
    def calculate_daily_signals(self, history: list[HalfDayCandle]) -> DailySignal:
        """00:00 시그널 계산"""
        # 변동성 돌파: threshold, buy_weight
        # 오전오후: condition_met, buy_weight
        return DailySignal(...)
```

### StrategyExecutor

```python
class StrategyExecutor:
    def check_and_buy(self, signals: DailySignal):
        """매 1분 체크 & 매수"""
        current_price = get_current_price()
        if current_price > signals.vb.threshold:
            self._buy('volatility', signals.vb.buy_weight)

    def sell_all(self):
        """12:00 전량 매도"""
```

### TradingScheduler

```python
class TradingScheduler:
    def setup(self):
        schedule.every().day.at("00:00:30").do(self.daily_routine)
        schedule.every(1).minutes.do(self.check_volatility)
        schedule.every().day.at("12:00:00").do(self.sell_all)
```

---

## 구현 순서 (TDD)

### Phase 1 - 데이터

- [ ] HalfDayCandle 모델
- [ ] DataCollector (60분봉 → 오전/오후)
- [ ] DataStorage (JSON)

### Phase 2 - 지표

- [ ] IndicatorCalculator (노이즈, 이평선)
- [ ] SignalCalculator (시그널 사전 계산)

### Phase 3 - 전략

- [ ] BaseStrategy
- [ ] MorningAfternoonStrategy
- [ ] VolatilityBreakoutStrategy

### Phase 4 - 실행

- [ ] StrategyExecutor
- [ ] TradingScheduler

### Phase 5 - 완성

- [ ] 시뮬레이션 모드
- [ ] 실전 모드

---

## 예외 처리

- 변동성 < 0.1%: 매수 안 함
- 레인지 = 0: 노이즈 0
- 데이터 < 20일: 워밍업
- 매수 비중 ≤ 0: 생략
- 매수 금액 < 5000원: 생략

---

## 실행

```bash
# 설치
uv pip install schedule

# 실행
PYTHONPATH=. uv run python strategy_runner.py
```

---

## API 호출 횟수 (일일)

- 00:00: 60분봉 36개 + 현재가 1회
- 00:01~11:59: 현재가 718회
- 12:00: 매도 1회
- **합계: ~721회** (Upbit 제한: 분당 200회)
